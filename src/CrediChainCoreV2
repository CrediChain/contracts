// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import "./SoulBoundNFT.sol";
import "./IdentityManager.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";

/**
 * @title CrediChainCore V2
 * @dev Enhanced core contract that manages the issuance and revocation of credentials in the form of soulbound NFTs,
 * with improved security, batch operations, reputation system, and multi-role access control.
 * @notice This contract allows verified institutions to issue credentials to verified users with enhanced features.
 */
contract CrediChainCoreV2 is AccessControl, ReentrancyGuard, Pausable {
    // Role definitions
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    bytes32 public constant INSTITUTION_VERIFIER_ROLE = keccak256("INSTITUTION_VERIFIER_ROLE");
    bytes32 public constant EMERGENCY_ROLE = keccak256("EMERGENCY_ROLE");

    error OnlyTheIssuerCanRevoke();
    error CrediChainCore__OnlyVerifiedInstitutions();
    error CrediChainCore__OnlyVerifiedUsers();
    error CrediChainCore__InstitutionAlreadyVerified();
    error CrediChainCore__InstitutionNotFound();
    error CrediChainCore__InvalidCredentialType();
    error CrediChainCore__CredentialExpired();
    error CrediChainCore__InsufficientReputation();
    error CrediChainCore__BatchSizeLimitExceeded();
    error CrediChainCore__InvalidInput();

   // Structs
    struct Institution {
        bool isVerified;
        uint256 reputation;
        uint256 credentialsIssued;
        uint256 credentialsRevoked;
        uint256 verificationTimestamp;
        string name;
        string website;
        InstitutionCategory category;
    }

    struct CredentialMetadata {
        address issuer;
        uint256 issuanceTimestamp;
        uint256 expirationTimestamp;
        CredentialType credentialType;
        bool isActive;
        string ipfsHash;
    }

    // Enums
    enum InstitutionCategory { UNIVERSITY, COLLEGE, CERTIFICATION_BODY, GOVERNMENT, OTHER }
    enum CredentialType { DEGREE, CERTIFICATE, DIPLOMA, LICENSE, BADGE }

    // State variables
    SoulBoundNFT public immutable soulBoundNFT;
    IdentityManager public immutable identityManager;

    mapping(address => Institution) public institutions;
    mapping(uint256 => CredentialMetadata) public credentialMetadata;
    mapping(CredentialType => uint256) public credentialTypeCount;
    mapping(address => uint256[]) public userCredentials;

    // Reputation and governance
    uint256 public constant MIN_REPUTATION_THRESHOLD = 100;
    uint256 public constant MAX_BATCH_SIZE = 50;
    uint256 public constant REPUTATION_DECAY_RATE = 5; // 5% per year

    address[] public verifiedInstitutionsList;
    uint256 public totalCredentialsIssued;
    uint256 public totalInstitutions;

    // Events
    event InstitutionVerified(
        address indexed institution, 
        string name, 
        InstitutionCategory category,
        uint256 timestamp
    );
    event InstitutionRemoved(address indexed institution, uint256 timestamp);
    event InstitutionReputationUpdated(address indexed institution, uint256 newReputation);
    event CredentialIssued(
        address indexed to,
        uint256 indexed tokenId,
        address indexed issuer,
        CredentialType credentialType,
        uint256 expirationTimestamp
    );
    event CredentialRevoked(
        uint256 indexed tokenId,
        address indexed issuer,
        address indexed holder,
        string reason
    );
    event BatchCredentialsIssued(
        address indexed issuer,
        uint256 count,
        uint256[] tokenIds
    );

    /**
     * @notice Initializes the CrediChainCore V2 contract
     * @param _soulBoundNFT The address of the SoulBoundNFT contract
     * @param _identityManager The address of the IdentityManager contract
     */
    constructor(
        address _soulBoundNFT,
        address _identityManager
    ) {
        if (_soulBoundNFT == address(0) || _identityManager == address(0)) {
            revert CrediChainCore__InvalidInput();
        }
        
        soulBoundNFT = SoulBoundNFT(_soulBoundNFT);
        identityManager = IdentityManager(_identityManager);
        
        // Set up roles
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(ADMIN_ROLE, msg.sender);
        _grantRole(INSTITUTION_VERIFIER_ROLE, msg.sender);
        _grantRole(EMERGENCY_ROLE, msg.sender);
        
        // Verify the deployer as the first institution
        _verifyInstitution(
            msg.sender,
            "Credichain Platform",
            "https://credichain.org",
            InstitutionCategory.OTHER
        );
    }

    /**
     * @notice Modifier to ensure caller is a verified institution with sufficient reputation
    */
    modifier onlyVerifiedInstitution() {
        Institution memory inst = institutions[msg.sender];
        if (!inst.isVerified || !identityManager.getIsVerified(msg.sender)) {
            revert CrediChainCore__OnlyVerifiedInstitutions();
        }
        if (inst.reputation < MIN_REPUTATION_THRESHOLD) {
            revert CrediChainCore__InsufficientReputation();
        }
        _;
    }

    /**
     * @notice Modifier to ensure target user is verified
    */
    modifier onlyVerifiedUser(address user) {
        if (!identityManager.getIsVerified(user)) {
            revert CrediChainCore__OnlyVerifiedUsers();
        }
        _;
    }

    /**
     * @notice Verifies an institution with enhanced metadata
     * @param institution Address of the institution
     * @param name Name of the institution
     * @param website Website URL of the institution
     * @param category Category of the institution
     */
    function verifyInstitution(
        address institution,
        string memory name,
        string memory website,
        InstitutionCategory category
    ) external onlyRole(INSTITUTION_VERIFIER_ROLE) whenNotPaused {
        if (institutions[institution].isVerified) {
            revert CrediChainCore__InstitutionAlreadyVerified();
        }
        _verifyInstitution(institution, name, website, category);
    }

    /**
     * @notice Internal function to verify institution
    */
    function _verifyInstitution(
        address institution,
        string memory name,
        string memory website,
        InstitutionCategory category
    ) internal {
        institutions[institution] = Institution({
            isVerified: true,
            reputation: MIN_REPUTATION_THRESHOLD,
            credentialsIssued: 0,
            credentialsRevoked: 0,
            verificationTimestamp: block.timestamp,
            name: name,
            website: website,
            category: category
        });
        
        verifiedInstitutionsList.push(institution);
        totalInstitutions++;
        
        emit InstitutionVerified(institution, name, category, block.timestamp);
    }

    /**
     * @notice Removes institution verification
     * @param institution Address of the institution to remove
    */
    function removeInstitution(address institution) 
        external 
        onlyRole(ADMIN_ROLE) 
        whenNotPaused 
    {
        if (!institutions[institution].isVerified) {
            revert CrediChainCore__InstitutionNotFound();
        }
        
        institutions[institution].isVerified = false;
        _removeFromInstitutionsList(institution);
        totalInstitutions--;
        
        emit InstitutionRemoved(institution, block.timestamp);
    }

    /**
     * @notice Issues a credential with expiration and type
     * @param to Address to receive the credential
     * @param uri Metadata URI
     * @param credentialType Type of credential being issued
     * @param expirationTimestamp When the credential expires (0 for no expiration)
     * @param ipfsHash IPFS hash for additional metadata
     */
    function issueCredential(
        address to,
        string memory uri,
        CredentialType credentialType,
        uint256 expirationTimestamp,
        string memory ipfsHash
    )
        external
        onlyVerifiedInstitution
        onlyVerifiedUser(to)
        whenNotPaused
        nonReentrant
        returns (uint256 tokenId)
    {
        tokenId = soulBoundNFT.safeMint(msg.sender, to, uri);
        
        credentialMetadata[tokenId] = CredentialMetadata({
            issuer: msg.sender,
            issuanceTimestamp: block.timestamp,
            expirationTimestamp: expirationTimestamp,
            credentialType: credentialType,
            isActive: true,
            ipfsHash: ipfsHash
        });
        
        userCredentials[to].push(tokenId);
        credentialTypeCount[credentialType]++;
        totalCredentialsIssued++;
        
        // Update institution stats
        institutions[msg.sender].credentialsIssued++;
        _updateReputation(msg.sender, true);
        
        emit CredentialIssued(
            to, 
            tokenId, 
            msg.sender, 
            credentialType, 
            expirationTimestamp
        );
        
        return tokenId;
    }

    /**
     * @notice Issues multiple credentials in a single transaction
     * @param recipients Array of recipient addresses
     * @param uris Array of metadata URIs
     * @param credentialTypes Array of credential types
     * @param expirationTimestamps Array of expiration timestamps
     * @param ipfsHashes Array of IPFS hashes
     */
    function batchIssueCredentials(
        address[] calldata recipients,
        string[] calldata uris,
        CredentialType[] calldata credentialTypes,
        uint256[] calldata expirationTimestamps,
        string[] calldata ipfsHashes
    )
        external
        onlyVerifiedInstitution
        whenNotPaused
        nonReentrant
        returns (uint256[] memory tokenIds)
    {
        uint256 length = recipients.length;
        if (length > MAX_BATCH_SIZE || length == 0) {
            revert CrediChainCore__BatchSizeLimitExceeded();
        }
        if (length != uris.length || length != credentialTypes.length || 
            length != expirationTimestamps.length || length != ipfsHashes.length) {
            revert CrediChainCore__InvalidInput();
        }

        tokenIds = new uint256[](length);
        
        for (uint256 i = 0; i < length;) {
            if (!identityManager.getIsVerified(recipients[i])) {
                revert CrediChainCore__OnlyVerifiedUsers();
            }
            
            tokenIds[i] = issueCredential(
                recipients[i],
                uris[i],
                credentialTypes[i],
                expirationTimestamps[i],
                ipfsHashes[i]
            );
            
            unchecked { ++i; }
        }
        
        emit BatchCredentialsIssued(msg.sender, length, tokenIds);
        return tokenIds;
    }

    /**
     * @notice Revokes a credential with reason
     * @param tokenId ID of the credential to revoke
     * @param reason Reason for revocation
     */
    function revokeCredential(uint256 tokenId, string calldata reason) 
        external 
        onlyVerifiedInstitution 
        whenNotPaused 
        nonReentrant 
    {
        CredentialMetadata storage metadata = credentialMetadata[tokenId];
        if (metadata.issuer != msg.sender) {
            revert OnlyTheIssuerCanRevoke();
        }
        if (!metadata.isActive) {
            revert CrediChainCore__InvalidInput();
        }
        
        address holder = soulBoundNFT.ownerOf(tokenId);
        soulBoundNFT.revoke(msg.sender, tokenId);
        
        metadata.isActive = false;
        institutions[msg.sender].credentialsRevoked++;
        _updateReputation(msg.sender, false);
        
        // Remove from user's credential list
        _removeFromUserCredentials(holder, tokenId);
        
        emit CredentialRevoked(tokenId, msg.sender, holder, reason);
    }

    /**
     * @notice Updates institution reputation based on actions
     * @param institution Address of the institution
     * @param positive Whether the action is positive (true) or negative (false)
     */
    function _updateReputation(address institution, bool positive) internal {
        Institution storage inst = institutions[institution];
        
        if (positive) {
            inst.reputation += 10; // Increase reputation for issuing credentials
        } else {
            if (inst.reputation >= 20) {
                inst.reputation -= 20; // Decrease reputation for revoking credentials
            }
        }
        
        emit InstitutionReputationUpdated(institution, inst.reputation);
    }

    /**
     * @notice Checks if a credential is valid (not expired and active)
     * @param tokenId ID of the credential
     * @return isValid Whether the credential is valid
     */
    function isCredentialValid(uint256 tokenId) external view returns (bool isValid) {
        CredentialMetadata memory metadata = credentialMetadata[tokenId];
        
        if (!metadata.isActive) return false;
        if (metadata.expirationTimestamp == 0) return true; // No expiration
        
        return block.timestamp <= metadata.expirationTimestamp;
    }

    /**
     * @notice Gets detailed credential information
     * @param tokenId ID of the credential
     * @return metadata Full credential metadata
     */
    function getCredentialDetails(uint256 tokenId) 
        external 
        view 
        returns (CredentialMetadata memory metadata) 
    {
        return credentialMetadata[tokenId];
    }

    /**
     * @notice Gets institution statistics
     * @param institution Address of the institution
     * @return institutionData Full institution data
     */
    function getInstitutionStats(address institution) 
        external 
        view 
        returns (Institution memory institutionData) 
    {
        return institutions[institution];
    }

    /**
     * @notice Gets all verified institutions
     * @return institutionAddresses Array of verified institution addresses
     */
    function getVerifiedInstitutions() 
        external 
        view 
        returns (address[] memory institutionAddresses) 
    {
        return verifiedInstitutionsList;
    }

    /**
     * @notice Gets credentials by type
     * @param credentialType Type of credentials to count
     * @return count Number of credentials of this type
     */
    function getCredentialCountByType(CredentialType credentialType) 
        external 
        view 
        returns (uint256 count) 
    {
        return credentialTypeCount[credentialType];
    }

    /**
     * @notice Gets platform statistics
     * @return stats Array containing [totalCredentials, totalInstitutions, totalActiveCredentials]
     */
    function getPlatformStats() 
        external 
        view 
        returns (uint256[3] memory stats) 
    {
        uint256 activeCredentials = totalCredentialsIssued;
        // In a real implementation, you'd iterate through all credentials to count active ones
        return [totalCredentialsIssued, totalInstitutions, activeCredentials];
    }

    /**
     * @notice Emergency pause function
     */
    function pause() external onlyRole(EMERGENCY_ROLE) {
        _pause();
    }

    /**
     * @notice Emergency unpause function
     */
    function unpause() external onlyRole(EMERGENCY_ROLE) {
        _unpause();
    }

    /**
     * @notice Internal function to remove institution from list
     */
    function _removeFromInstitutionsList(address institution) internal {
        for (uint256 i = 0; i < verifiedInstitutionsList.length; i++) {
            if (verifiedInstitutionsList[i] == institution) {
                verifiedInstitutionsList[i] = verifiedInstitutionsList[verifiedInstitutionsList.length - 1];
                verifiedInstitutionsList.pop();
                break;
            }
        }
    }

    /**
     * @notice Internal function to remove credential from user's list
     */
    function _removeFromUserCredentials(address user, uint256 tokenId) internal {
        uint256[] storage credentials = userCredentials[user];
        for (uint256 i = 0; i < credentials.length; i++) {
            if (credentials[i] == tokenId) {
                credentials[i] = credentials[credentials.length - 1];
                credentials.pop();
                break;
            }
        }

    function getCredentialIssuer(uint256 tokenId) external view returns (address) {
        return credentialMetadata[tokenId].issuer;
    }

    function getIsInstitutuinVerified(address institution) external view returns (bool) {
        return institutions[institution].isVerified;
    }
}
