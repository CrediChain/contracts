// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import "./SoulBoundNFT.sol";
import "./IdentityManager.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";

/**
 * @title CrediChainCore V2
 * @dev Enhanced core contract that manages the issuance and revocation of credentials in the form of soulbound NFTs,
 * with improved security, batch operations, reputation system, and multi-role access control.
 * @notice This contract allows verified institutions to issue credentials to verified users with enhanced features.
 */
contract CrediChainCoreV2 is AccessControl, ReentrancyGuard, Pausable {
    // Role definitions
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    bytes32 public constant INSTITUTION_VERIFIER_ROLE = keccak256("INSTITUTION_VERIFIER_ROLE");
    bytes32 public constant EMERGENCY_ROLE = keccak256("EMERGENCY_ROLE");

    error OnlyTheIssuerCanRevoke();
    error CrediChainCore__OnlyVerifiedInstitutions();
    error CrediChainCore__OnlyVerifiedUsers();
    error CrediChainCore__InstitutionAlreadyVerified();
    error CrediChainCore__InstitutionNotFound();
    error CrediChainCore__InvalidCredentialType();
    error CrediChainCore__CredentialExpired();
    error CrediChainCore__InsufficientReputation();
    error CrediChainCore__BatchSizeLimitExceeded();
    error CrediChainCore__InvalidInput();

   // Structs
    struct Institution {
        bool isVerified;
        uint256 reputation;
        uint256 credentialsIssued;
        uint256 credentialsRevoked;
        uint256 verificationTimestamp;
        string name;
        string website;
        InstitutionCategory category;
    }

    struct CredentialMetadata {
        address issuer;
        uint256 issuanceTimestamp;
        uint256 expirationTimestamp;
        CredentialType credentialType;
        bool isActive;
        string ipfsHash;
    }

    // Enums
    enum InstitutionCategory { UNIVERSITY, COLLEGE, CERTIFICATION_BODY, GOVERNMENT, OTHER }
    enum CredentialType { DEGREE, CERTIFICATE, DIPLOMA, LICENSE, BADGE }

    // State variables
    SoulBoundNFT public immutable soulBoundNFT;
    IdentityManager public immutable identityManager;

    mapping(address => Institution) public institutions;
    mapping(uint256 => CredentialMetadata) public credentialMetadata;
    mapping(CredentialType => uint256) public credentialTypeCount;
    mapping(address => uint256[]) public userCredentials;

    // Reputation and governance
    uint256 public constant MIN_REPUTATION_THRESHOLD = 100;
    uint256 public constant MAX_BATCH_SIZE = 50;
    uint256 public constant REPUTATION_DECAY_RATE = 5; // 5% per year

    address[] public verifiedInstitutionsList;
    uint256 public totalCredentialsIssued;
    uint256 public totalInstitutions;

    // Events
    event InstitutionVerified(
        address indexed institution, 
        string name, 
        InstitutionCategory category,
        uint256 timestamp
    );
    event InstitutionRemoved(address indexed institution, uint256 timestamp);
    event InstitutionReputationUpdated(address indexed institution, uint256 newReputation);
    event CredentialIssued(
        address indexed to,
        uint256 indexed tokenId,
        address indexed issuer,
        CredentialType credentialType,
        uint256 expirationTimestamp
    );
    event CredentialRevoked(
        uint256 indexed tokenId,
        address indexed issuer,
        address indexed holder,
        string reason
    );
    event BatchCredentialsIssued(
        address indexed issuer,
        uint256 count,
        uint256[] tokenIds
    );

    /**
     * @notice Initializes the CrediChainCore V2 contract
     * @param _soulBoundNFT The address of the SoulBoundNFT contract
     * @param _identityManager The address of the IdentityManager contract
     */
    constructor(
        address _soulBoundNFT,
        address _identityManager
    ) {
        if (_soulBoundNFT == address(0) || _identityManager == address(0)) {
            revert CrediChainCore__InvalidInput();
        }
        
        soulBoundNFT = SoulBoundNFT(_soulBoundNFT);
        identityManager = IdentityManager(_identityManager);
        
        // Set up roles
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(ADMIN_ROLE, msg.sender);
        _grantRole(INSTITUTION_VERIFIER_ROLE, msg.sender);
        _grantRole(EMERGENCY_ROLE, msg.sender);
        
        // Verify the deployer as the first institution
        _verifyInstitution(
            msg.sender,
            "Credichain Platform",
            "https://credichain.org",
            InstitutionCategory.OTHER
        );
    }

    /**
     * @notice Modifier to ensure caller is a verified institution with sufficient reputation
    */
    modifier onlyVerifiedInstitution() {
        Institution memory inst = institutions[msg.sender];
        if (!inst.isVerified || !identityManager.getIsVerified(msg.sender)) {
            revert CrediChainCore__OnlyVerifiedInstitutions();
        }
        if (inst.reputation < MIN_REPUTATION_THRESHOLD) {
            revert CrediChainCore__InsufficientReputation();
        }
        _;
    }

    /**
     * @notice Modifier to ensure target user is verified
    */
    modifier onlyVerifiedUser(address user) {
        if (!identityManager.getIsVerified(user)) {
            revert CrediChainCore__OnlyVerifiedUsers();
        }
        _;
    }

    /**
     * @notice Verifies an institution with enhanced metadata
     * @param institution Address of the institution
     * @param name Name of the institution
     * @param website Website URL of the institution
     * @param category Category of the institution
     */
    function verifyInstitution(
        address institution,
        string memory name,
        string memory website,
        InstitutionCategory category
    ) external onlyRole(INSTITUTION_VERIFIER_ROLE) whenNotPaused {
        if (institutions[institution].isVerified) {
            revert CrediChainCore__InstitutionAlreadyVerified();
        }
        _verifyInstitution(institution, name, website, category);
    }

    /**
     * @notice Internal function to verify institution
    */
    function _verifyInstitution(
        address institution,
        string memory name,
        string memory website,
        InstitutionCategory category
    ) internal {
        institutions[institution] = Institution({
            isVerified: true,
            reputation: MIN_REPUTATION_THRESHOLD,
            credentialsIssued: 0,
            credentialsRevoked: 0,
            verificationTimestamp: block.timestamp,
            name: name,
            website: website,
            category: category
        });
        
        verifiedInstitutionsList.push(institution);
        totalInstitutions++;
        
        emit InstitutionVerified(institution, name, category, block.timestamp);
    }

    /**
     * @notice Removes institution verification
     * @param institution Address of the institution to remove
    */
    function removeInstitution(address institution) 
        external 
        onlyRole(ADMIN_ROLE) 
        whenNotPaused 
    {
        if (!institutions[institution].isVerified) {
            revert CrediChainCore__InstitutionNotFound();
        }
        
        institutions[institution].isVerified = false;
        _removeFromInstitutionsList(institution);
        totalInstitutions--;
        
        emit InstitutionRemoved(institution, block.timestamp);
    }

    function issueCredential(
        address to,
        string memory uri,
        CredentialType credentialType,
        uint256 expirationTimestamp,
        string memory ipfsHash
    )
        external
        onlyVerifiedInstitution
        onlyVerifiedUser(to)
        whenNotPaused
        nonReentrant
        returns (uint256 tokenId)
    {
        tokenId = soulBoundNFT.safeMint(msg.sender, to, uri);
        
        credentialMetadata[tokenId] = CredentialMetadata({
            issuer: msg.sender,
            issuanceTimestamp: block.timestamp,
            expirationTimestamp: expirationTimestamp,
            credentialType: credentialType,
            isActive: true,
            ipfsHash: ipfsHash
        });
        
        userCredentials[to].push(tokenId);
        credentialTypeCount[credentialType]++;
        totalCredentialsIssued++;
        
        // Update institution stats
        institutions[msg.sender].credentialsIssued++;
        _updateReputation(msg.sender, true);
        
        emit CredentialIssued(
            to, 
            tokenId, 
            msg.sender, 
            credentialType, 
            expirationTimestamp
        );
        
        return tokenId;
    }
}
